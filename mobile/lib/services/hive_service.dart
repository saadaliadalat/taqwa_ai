import 'package:hive_flutter/hive_flutter.dart';
import '../models/user_model.dart';
import '../models/conversation_model.dart';
import '../models/message_model.dart';
import '../models/favorite_model.dart';
import '../models/ayah_model.dart';
import '../models/surah_model.dart';
import '../models/hadith_model.dart';

/// Hive Service for offline data storage
class HiveService {
  // Box names
  static const String _userBox = 'user_box';
  static const String _conversationsBox = 'conversations_box';
  static const String _messagesBox = 'messages_box';
  static const String _favoritesBox = 'favorites_box';
  static const String _quranCacheBox = 'quran_cache_box';
  static const String _settingsBox = 'settings_box';
  static const String _dailyAyahBox = 'daily_ayah_box';

  // Boxes
  late Box<dynamic> _user;
  late Box<dynamic> _conversations;
  late Box<dynamic> _messages;
  late Box<dynamic> _favorites;
  late Box<dynamic> _quranCache;
  late Box<dynamic> _settings;
  late Box<dynamic> _dailyAyah;

  /// Initialize Hive and open boxes
  Future<void> init() async {
    await Hive.initFlutter();
    
    // Register adapters (generated by build_runner)
    // These will be generated files - for now we use dynamic boxes
    
    // Open boxes
    _user = await Hive.openBox(_userBox);
    _conversations = await Hive.openBox(_conversationsBox);
    _messages = await Hive.openBox(_messagesBox);
    _favorites = await Hive.openBox(_favoritesBox);
    _quranCache = await Hive.openBox(_quranCacheBox);
    _settings = await Hive.openBox(_settingsBox);
    _dailyAyah = await Hive.openBox(_dailyAyahBox);
  }

  /// Close all boxes
  Future<void> close() async {
    await Hive.close();
  }

  /// Clear all data
  Future<void> clearAll() async {
    await _user.clear();
    await _conversations.clear();
    await _messages.clear();
    await _favorites.clear();
    await _quranCache.clear();
    await _settings.clear();
    await _dailyAyah.clear();
  }

  // ============================================
  // User Data
  // ============================================

  /// Save user data
  Future<void> saveUser(Map<String, dynamic> userData) async {
    await _user.put('current_user', userData);
  }

  /// Get user data
  Map<String, dynamic>? getUser() {
    final data = _user.get('current_user');
    if (data == null) return null;
    return Map<String, dynamic>.from(data as Map);
  }

  /// Clear user data
  Future<void> clearUser() async {
    await _user.delete('current_user');
  }

  // ============================================
  // Conversations
  // ============================================

  /// Save a conversation
  Future<void> saveConversation(String id, Map<String, dynamic> data) async {
    await _conversations.put(id, data);
  }

  /// Get a conversation by ID
  Map<String, dynamic>? getConversation(String id) {
    final data = _conversations.get(id);
    if (data == null) return null;
    return Map<String, dynamic>.from(data as Map);
  }

  /// Get all conversations
  List<Map<String, dynamic>> getAllConversations() {
    return _conversations.values
        .map((e) => Map<String, dynamic>.from(e as Map))
        .toList();
  }

  /// Delete a conversation
  Future<void> deleteConversation(String id) async {
    await _conversations.delete(id);
    // Also delete associated messages
    final messageKeys = _messages.keys
        .where((key) => key.toString().startsWith('${id}_'))
        .toList();
    for (final key in messageKeys) {
      await _messages.delete(key);
    }
  }

  /// Get conversations that need syncing
  List<Map<String, dynamic>> getUnsyncedConversations() {
    return _conversations.values
        .map((e) => Map<String, dynamic>.from(e as Map))
        .where((c) => c['needsSync'] == true)
        .toList();
  }

  /// Mark conversation as synced
  Future<void> markConversationSynced(String id) async {
    final data = getConversation(id);
    if (data != null) {
      data['needsSync'] = false;
      await saveConversation(id, data);
    }
  }

  // ============================================
  // Messages
  // ============================================

  /// Save a message
  Future<void> saveMessage(String conversationId, String messageId, Map<String, dynamic> data) async {
    await _messages.put('${conversationId}_$messageId', data);
  }

  /// Get messages for a conversation
  List<Map<String, dynamic>> getMessages(String conversationId) {
    return _messages.keys
        .where((key) => key.toString().startsWith('${conversationId}_'))
        .map((key) => Map<String, dynamic>.from(_messages.get(key) as Map))
        .toList()
      ..sort((a, b) => DateTime.parse(a['createdAt'] as String)
          .compareTo(DateTime.parse(b['createdAt'] as String)));
  }

  /// Delete a message
  Future<void> deleteMessage(String conversationId, String messageId) async {
    await _messages.delete('${conversationId}_$messageId');
  }

  // ============================================
  // Favorites
  // ============================================

  /// Save a favorite
  Future<void> saveFavorite(String id, Map<String, dynamic> data) async {
    await _favorites.put(id, data);
  }

  /// Get a favorite by ID
  Map<String, dynamic>? getFavorite(String id) {
    final data = _favorites.get(id);
    if (data == null) return null;
    return Map<String, dynamic>.from(data as Map);
  }

  /// Get all favorites
  List<Map<String, dynamic>> getAllFavorites() {
    return _favorites.values
        .map((e) => Map<String, dynamic>.from(e as Map))
        .toList();
  }

  /// Get favorites by type
  List<Map<String, dynamic>> getFavoritesByType(String type) {
    return _favorites.values
        .map((e) => Map<String, dynamic>.from(e as Map))
        .where((f) => f['type'] == type)
        .toList();
  }

  /// Delete a favorite
  Future<void> deleteFavorite(String id) async {
    await _favorites.delete(id);
  }

  /// Get favorites that need syncing
  List<Map<String, dynamic>> getUnsyncedFavorites() {
    return _favorites.values
        .map((e) => Map<String, dynamic>.from(e as Map))
        .where((f) => f['needsSync'] == true)
        .toList();
  }

  /// Mark favorite as synced
  Future<void> markFavoriteSynced(String id) async {
    final data = getFavorite(id);
    if (data != null) {
      data['needsSync'] = false;
      await saveFavorite(id, data);
    }
  }

  // ============================================
  // Quran Cache
  // ============================================

  /// Save surah data
  Future<void> saveSurah(int surahNumber, Map<String, dynamic> data) async {
    await _quranCache.put('surah_$surahNumber', data);
  }

  /// Get cached surah data
  Map<String, dynamic>? getSurah(int surahNumber) {
    final data = _quranCache.get('surah_$surahNumber');
    if (data == null) return null;
    return Map<String, dynamic>.from(data as Map);
  }

  /// Save ayahs for a surah
  Future<void> saveSurahAyahs(int surahNumber, List<Map<String, dynamic>> ayahs) async {
    await _quranCache.put('ayahs_$surahNumber', ayahs);
  }

  /// Get cached ayahs for a surah
  List<Map<String, dynamic>>? getSurahAyahs(int surahNumber) {
    final data = _quranCache.get('ayahs_$surahNumber');
    if (data == null) return null;
    return (data as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();
  }

  /// Check if surah is cached
  bool isSurahCached(int surahNumber) {
    return _quranCache.containsKey('ayahs_$surahNumber');
  }

  /// Save all surahs metadata
  Future<void> saveSurahsList(List<Map<String, dynamic>> surahs) async {
    await _quranCache.put('surahs_list', surahs);
  }

  /// Get all surahs metadata
  List<Map<String, dynamic>>? getSurahsList() {
    final data = _quranCache.get('surahs_list');
    if (data == null) return null;
    return (data as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();
  }

  // ============================================
  // Daily Ayah
  // ============================================

  /// Save daily ayah
  Future<void> saveDailyAyah(Map<String, dynamic> ayah, String date) async {
    await _dailyAyah.put('daily_$date', ayah);
    await _dailyAyah.put('last_daily_date', date);
  }

  /// Get daily ayah for a date
  Map<String, dynamic>? getDailyAyah(String date) {
    final data = _dailyAyah.get('daily_$date');
    if (data == null) return null;
    return Map<String, dynamic>.from(data as Map);
  }

  /// Get last daily ayah date
  String? getLastDailyAyahDate() {
    return _dailyAyah.get('last_daily_date') as String?;
  }

  // ============================================
  // Settings
  // ============================================

  /// Save a setting
  Future<void> saveSetting(String key, dynamic value) async {
    await _settings.put(key, value);
  }

  /// Get a setting
  T? getSetting<T>(String key, {T? defaultValue}) {
    return _settings.get(key, defaultValue: defaultValue) as T?;
  }

  /// Check if onboarding is complete
  bool get isOnboardingComplete {
    return _settings.get('onboarding_complete', defaultValue: false) as bool;
  }

  /// Mark onboarding as complete
  Future<void> completeOnboarding() async {
    await _settings.put('onboarding_complete', true);
  }

  /// Get last read position
  Map<String, dynamic>? getLastReadPosition() {
    final data = _settings.get('last_read_position');
    if (data == null) return null;
    return Map<String, dynamic>.from(data as Map);
  }

  /// Save last read position
  Future<void> saveLastReadPosition(int surahNumber, int ayahNumber) async {
    await _settings.put('last_read_position', {
      'surahNumber': surahNumber,
      'ayahNumber': ayahNumber,
      'timestamp': DateTime.now().toIso8601String(),
    });
  }

  /// Get dark mode preference
  bool get isDarkMode {
    return _settings.get('dark_mode', defaultValue: false) as bool;
  }

  /// Set dark mode preference
  Future<void> setDarkMode(bool value) async {
    await _settings.put('dark_mode', value);
  }

  /// Get notification preference
  bool get notificationsEnabled {
    return _settings.get('notifications_enabled', defaultValue: true) as bool;
  }

  /// Set notification preference
  Future<void> setNotificationsEnabled(bool value) async {
    await _settings.put('notifications_enabled', value);
  }
}
